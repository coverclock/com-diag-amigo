#ifndef _COM_DIAG_AMIGO_LITTLEENDIAN_H_
#define _COM_DIAG_AMIGO_LITTLEENDIAN_H_

/**
 * @file
 * Copyright 2012 Digital Aggregates Corporation, Colorado, USA\n
 * Licensed under the terms in README.h\n
 * Chip Overclock mailto:coverclock@diag.com\n
 * http://www.diag.com/navigation/downloads/Amigo.html\n
 * Adapted from Desperado\n
 * http://www.diag.com/navigation/downloads/Desperado.html\n
 * Unlike processors whose basic word size is larger than eight bits (sixteen,
 * thirty-two, sixty-four, typically), I think the endianess of the eight-
 * bit AVR is mostly an artifact of the code generated by the compiler, which
 * chooses to do multi-byte arithmetic in little-endian order. There are
 * sixteen-bit registers implemented as two eight-bit registers logically
 * concantenated together, and the higher order register is at the higher
 * memory address. For example, the Stack Pointer: SPL (low) at 0x3D, SPH (high)
 * at 0x3E, which is little-endian. But even so, AFAIK the SP can't be addressed
 * atomically by the application as a sixteen-bit word. So while the megaAVR
 * isn't entirely endian-neutral, its endianess as a practical matter seems to
 * be largely an artifact of the tool chain. This is a new concept to me.
 */

#include "com/diag/amigo/types.h"
#include "com/diag/amigo/cxxcapi.h"

// Naturally I wouldn't expect shorts, longs, and longs longs to have different
// byte orders. Nor does the AVR have such a peculiarity. But it would be very
// good indeed to know if an architecture had a strange byte ordering. Since
// I expect the compiler to optimize these down to just true or false, this is
// no real additional overhead.

/**
 *  Return true if the target has little-endian byte order, false if
 *  big-endian. True means that multi-byte integer types on this host
 *  must be swapped to be in network byte order, which is big-endian.
 *  It is entirely possible that the compiler will optimize this completely
 *  away to a constant value since it can be determined at compile time.
 *  @return true if little-endian, false if big-endian.
 */
CXXCINLINE bool amigo_littleendian16() {
    static union { uint16_t word; uint8_t byte[sizeof(uint16_t)]; } datum = { 1 };
    return (datum.byte[0] != 0);
}

/**
 *  Return true if the target has little-endian byte order, false if
 *  big-endian. True means that multi-byte integer types on this host
 *  must be swapped to be in network byte order, which is big-endian.
 *  It is entirely possible that the compiler will optimize this completely
 *  away to a constant value since it can be determined at compile time.
 *  @return true if little-endian, false if big-endian.
 */
CXXCINLINE bool amigo_littleendian32() {
    static union { uint32_t word; uint8_t byte[sizeof(uint32_t)]; } datum = { 1 };
    return (datum.byte[0] != 0);
}

/**
 *  Return true if the target has little-endian byte order, false if
 *  big-endian. True means that multi-byte integer types on this host
 *  must be swapped to be in network byte order, which is big-endian.
 *  It is entirely possible that the compiler will optimize this completely
 *  away to a constant value since it can be determined at compile time.
 *  @return true if little-endian, false if big-endian.
 */
CXXCINLINE bool amigo_littleendian64() {
    static union { uint64_t word; uint8_t byte[sizeof(uint64_t)]; } datum = { 1 };
    return (datum.byte[0] != 0);
}

namespace com {
namespace diag {
namespace amigo {
namespace byteorder {

/**
 *  Return true if the target has little-endian byte order, false if
 *  big-endian. True means that multi-byte integer types on this host
 *  must be swapped to be in network byte order, which is big-endian.
 *  It is entirely possible that the compiler will optimize this completely
 *  away to a constant value since it can be determined at compile time.
 *  @return true if little-endian, false if big-endian.
 */
inline bool littleendian() {
	return amigo_littleendian16();
}

/**
 *  Return true if the target has little-endian byte order, false if
 *  big-endian. True means that multi-byte integer types on this host
 *  must be swapped to be in network byte order, which is big-endian.
 *  It is entirely possible that the compiler will optimize this completely
 *  away to a constant value since it can be determined at compile time.
 *  @return true if little-endian, false if big-endian.
 */
inline bool littleendian16() {
	return amigo_littleendian16();
}

/**
 *  Return true if the target has little-endian byte order, false if
 *  big-endian. True means that multi-byte integer types on this host
 *  must be swapped to be in network byte order, which is big-endian.
 *  It is entirely possible that the compiler will optimize this completely
 *  away to a constant value since it can be determined at compile time.
 *  @return true if little-endian, false if big-endian.
 */
inline bool littleendian32() {
	return amigo_littleendian32();
}

/**
 *  Return true if the target has little-endian byte order, false if
 *  big-endian. True means that multi-byte integer types on this host
 *  must be swapped to be in network byte order, which is big-endian.
 *  It is entirely possible that the compiler will optimize this completely
 *  away to a constant value since it can be determined at compile time.
 *  @return true if little-endian, false if big-endian.
 */
inline bool littleendian64() {
	return amigo_littleendian64();
}

}
}
}
}

#endif /* _COM_DIAG_AMIGO_LITTLEENDIAN_H_ */
